#!/usr/bin/env ruby

# Requirements
require "tty-prompt"
require "tty-spinner"
require "yaml"
require "date"

# Initialise Variables
report_dir = File.expand_path(File.join(__FILE__,'../../'))

require_relative "#{report_dir}/lib/metrics"

username = ENV['USER']
issue_date = Time.now.strftime("%Y%m%d")
issue_time = Time.now.strftime("%H%M%S")

logdir = report_dir + '/var/reports'

issues = {}
issuesdir = report_dir + '/etc/issues'

config = report_dir + '/etc/config.yaml'

# Config options
if File.file?(config)
  config = YAML.load_file("#{report_dir}/etc/config.yaml") || nil
end

# Create prompt
prompt = TTY::Prompt.new(active_color: :blue, interrupt: :exit)

# Check with user
if ! config['always_report'] 
  report = prompt.yes?('Would you like to report an issue?', default: false)
  if ! report
    puts "Not reporting anything."
    exit
  end
end

# Select issue
## Identify issues by directory name so we can run scripts and things from in there
issuedirs = Dir.entries(issuesdir).select{|dir| !(dir == '.' || dir == '..' || dir == 'general')}
## Create a map of all the issue directories and their metadata+questions
issuedirs.each do |issue|
  issuedir = "#{issuesdir}/#{issue}"
  issues[issue] = YAML.load_file("#{issuedir}/metadata.yaml")
  if File.file? "#{issuedir}/questions.yaml"
    issues[issue]['questions'] = YAML.load_file("#{issuedir}/questions.yaml")
  end
end
my_issue_dir = prompt.select("What issue would you like to report?") do |menu|
  issues.each.map {|dir,data| menu.choice "#{data['title']} (#{data['desc']})", dir}
end

my_issue = issues[my_issue_dir]

# Ask additional questions
diag_vars = {}
if my_issue.key?('questions') then
  my_issue['questions'].each do |question|
    case question['type']
    when "boolean"
      answer = prompt.yes?(question['question'])
    when "list"
      answer = prompt.select(question['question'], question['options'])
    when "text"
      answer = prompt.ask(question['question'])
    when "number"
      answer = prompt.ask(question['question']) do |q|
        q.validate(/^[0-9]*$/, "Answer must be a number or empty")
      end
    end
    diag_vars[question['var']] = answer
  end
end

# Check metrics
spinner = TTY::Spinner.new(":spinner Checking metrics ...", format: :bouncing_ball)
spinner.auto_spin

## Run general metrics
general_metrics_file = "#{issuesdir}/general/metrics.yaml"
metrics_out = {}

if File.file?(general_metrics_file)
  metrics_out.merge!(check_metrics(general_metrics_file))
end

## Run issue-specific metrics
issue_metrics_file = "#{issuesdir}/#{my_issue_dir}/metrics.yaml"

if File.file?(issue_metrics_file)
  diag_vars.each do |key, val|
    ENV[key] = val
  end
  metrics_out.merge!(check_metrics(issue_metrics_file))
end

## Wait for grace period
sleep(config['metric_grace_period'] || 0)

## Tell user pass/fail of metrics
failcount, failmetrics = failed_metrics(metrics_out)
if failcount == 0
  spinner.success("All Checks Passed")
else
  spinner.error("Warning with #{failcount}/#{metrics_out.count} Checks")
  report_metrics_detail(metrics_out)
end

## TODO: Save metrics

# Run diagnostics
spinner = TTY::Spinner.new(":spinner Running diagnostics ...", format: :bouncing_ball)
spinner.auto_spin

general_scripts = Dir.glob("#{issuesdir}/general/*.bash")
## General scripts
general_script_outputs = []
general_scripts.each do |script|
  general_script_outputs.append(`bash #{script} 2>&1`)
end

## Issue specific
issue_script = "#{issuesdir}/#{my_issue_dir}/diagnostics.bash"

if File.file?(issue_script)
  diag_vars.each do |key, val|
    ENV[key] = val
  end

  issue_script_out = `bash #{issue_script} 2>&1`
end

## Wait for grace period
sleep(config['diagnostic_grace_period'] || 0)
spinner.success("Done!")

## Combine diagnostics
diag_out = general_script_outputs + [issue_script_out]

# Show diagnostics to user
if ! config['hide_diagnostics']
  view = prompt.yes?("Would you like to view diagnostics?", default: false)
  if view
    IO.popen("less", "w") { |f| f.puts diag_out }
  end
end

# Compare to previous
if ! config['hide_compare']
  prev_report_from_user = Dir.glob("#{logdir}/.user-report-#{my_issue_dir}-#{username}*.log").last

  if prev_report_from_user && File.file?(prev_report_from_user)
    # Identify metadata from filename of previous report
    ## Array of ["", "user", "report", ISSUE_NAME, USERNAME, DATE, TIME, "log"]
    prev_data = File.basename(prev_report_from_user).split(/[-,.]/)
    prev_datetime = DateTime.parse(prev_data[-3] + prev_data[-2])
    compare = prompt.yes?("Would you like to compare diagnostics to your previous report at #{prev_datetime.strftime("%Y-%m-%d %H:%M:%S")}?", default: false)
    if compare
      current = "# Current Diagnostics: #{DateTime.parse(issue_date + issue_time).strftime("%Y-%m-%d %H:%M:%S")}\n#{diag_out.join('\n')}"
      previous = "# Previous Diagnostics: #{prev_datetime.strftime("%Y-%m-%d %H:%M:%S")}\n#{File.read(prev_report_from_user)}"
      diff_to_prev = `diff -y --width=#{`tput cols`.to_i} <(echo -e '#{current}') <(echo -e '#{previous}')`
      IO.popen("less", "w") { |f| f.puts diff_to_prev }
    end
  end
end

# Logging diagnostics
logfile = "#{logdir}/.user-report-#{my_issue_dir}-#{username}-#{issue_date}-#{issue_time}.log"
if ! config['always_send']
  confirm = false
else
  confirm = true
  report = true
end
until confirm
  report = prompt.yes?("Would you like to send diagnostics report for '#{my_issue['title']}' to admin?", default: false)
  confirm = prompt.yes?("  Are you sure?", default: false)
end

if report
  File.open(logfile, 'a+') do |f|
    f.puts(diag_out)
  end
  puts "Log reported, thank you for your time"
else
  puts "Not reporting, thank you for your time"
  exit
end
